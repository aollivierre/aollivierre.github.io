# Required modules
#Requires -Modules PSWriteHTML

function Get-GoDaddyAuthHeader {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)]
        [string]$ApiKey,
        
        [Parameter(Mandatory)]
        [string]$ApiSecret
    )
    
    @{
        "Authorization" = "sso-key $($ApiKey):$($ApiSecret)"
    }
}

function Get-DomainAvailability {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)]
        [string]$Domain,
        
        [Parameter(Mandatory)]
        [hashtable]$Headers,

        [Parameter()]
        [string]$Environment = 'Production'
    )
    
    try {
        # Determine API endpoint based on environment
        $baseUrl = if ($Environment -eq 'Production') {
            'https://api.godaddy.com'
        } else {
            'https://api.ote-godaddy.com'
        }

        $params = @{
            Uri = "$baseUrl/v1/domains/available?domain=$Domain"
            Headers = $Headers
            Method = 'GET'
            ErrorAction = 'Stop'
            ContentType = 'application/json'
        }
        
        Write-Verbose "Checking domain availability for: $Domain"
        Write-Verbose "Using endpoint: $($params.Uri)"
        
        $response = Invoke-RestMethod @params
        
        [PSCustomObject]@{
            Domain = $Domain
            Available = [bool]$response.available
            PricePerYear = if ($null -ne $response.price) { 
                [math]::Round($response.price / 1000000, 2)
            } else { 
                0 
            }
            Currency = if ($null -ne $response.currency) {
                $response.currency
            } else {
                'N/A'
            }
            Status = 'Success'
            Error = ''
        }
    }
    catch {
        Write-Warning "Error checking domain $Domain : $($_.Exception.Message)"
        
        [PSCustomObject]@{
            Domain = $Domain
            Available = $false
            Price = 0
            Currency = 'N/A'
            Status = 'Failed'
            Error = $_.Exception.Message
        }
    }
}

function Export-DomainReport {
    param(
        [Parameter(Mandatory)]
        [array]$Results,
        
        [Parameter(Mandatory)]
        [string]$OutputPath
    )
    
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $htmlPath = Join-Path $OutputPath "DomainReport_$timestamp.html"
    $csvPath = Join-Path $OutputPath "DomainReport_$timestamp.csv"
    
    # Export to CSV
    $Results | Export-Csv -Path $csvPath -NoTypeInformation
    
    $availableDomains = $Results | Where-Object Available -eq $true
    
    $metadata = @{
        GeneratedBy = $env:USERNAME
        GeneratedOn = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        TotalDomains = $Results.Count
        AvailableDomains = $availableDomains.Count
        UnavailableDomains = ($Results | Where-Object Available -eq $false).Count
        FailedChecks = ($Results | Where-Object Status -eq "Failed").Count
    }
    
    # Calculate price statistics only if there are available domains
    if ($availableDomains.Count -gt 0) {
        $priceStats = $availableDomains | Measure-Object -Property PricePerYear -Average -Minimum -Maximum
        $metadata['AveragePricePerYear'] = "$" + [math]::Round($priceStats.Average, 2)
        $metadata['MinPricePerYear'] = "$" + [math]::Round($priceStats.Minimum, 2)
        $metadata['MaxPricePerYear'] = "$" + [math]::Round($priceStats.Maximum, 2)
    }
    
    New-HTML -Title "Domain Availability Report" -FilePath $htmlPath -ShowHTML {
        New-HTMLSection -HeaderText "Report Summary" {
            New-HTMLPanel {
                New-HTMLText -Text @"
                <h3>Report Details</h3>
                <ul>
                    <li>Generated By: $($metadata.GeneratedBy)</li>
                    <li>Generated On: $($metadata.GeneratedOn)</li>
                    <li>Generated By: $($metadata.GeneratedBy)</li>
                    <li>Generated On: $($metadata.GeneratedOn)</li>
                    <li>Total Domains Checked: $($metadata.TotalDomains)</li>
                    <li>Available Domains: $($metadata.AvailableDomains)</li>
                    <li>Unavailable Domains: $($metadata.UnavailableDomains)</li>
                    <li>Failed Checks: $($metadata.FailedChecks)</li>
$(if ($metadata.ContainsKey('AveragePricePerYear')) {
@"
                    <li>Average Price Per Year: $($metadata.AveragePricePerYear)</li>
                    <li>Minimum Price Per Year: $($metadata.MinPricePerYear)</li>
                    <li>Maximum Price Per Year: $($metadata.MaxPricePerYear)</li>
"@
})
                </ul>
"@
            }
        }
        
        New-HTMLSection -HeaderText "Domain Availability Results" {
            New-HTMLTable -DataTable $Results -ScrollX -Buttons @('copyHtml5', 'excelHtml5', 'csvHtml5') {
                New-TableCondition -Name 'Available' -ComparisonType string -Operator eq -Value 'True' -BackgroundColor LightGreen -Color Black
                New-TableCondition -Name 'Available' -ComparisonType string -Operator eq -Value 'False' -BackgroundColor Salmon -Color Black
                New-TableCondition -Name 'Status' -ComparisonType string -Operator eq -Value 'Failed' -BackgroundColor Red -Color White
            }
        }
    }
    
    Write-Host "`nReports generated:" -ForegroundColor Green
    Write-Host "CSV Report: $csvPath" -ForegroundColor Green
    Write-Host "HTML Report: $htmlPath" -ForegroundColor Green
    
    return @{
        CSVPath = $csvPath
        HTMLPath = $htmlPath
    }
}

function Test-BulkDomains {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory, ParameterSetName = 'Direct')]
        [string[]]$DomainNames,
        
        [Parameter(Mandatory, ParameterSetName = 'CSV')]
        [string]$CsvPath,
        
        [Parameter(Mandatory)]
        [string]$ApiKey,
        
        [Parameter(Mandatory)]
        [string]$ApiSecret,
        
        [Parameter()]
        [ValidateSet('Production', 'Test')]
        [string]$Environment = 'Production',
        
        [Parameter()]
        [string]$OutputPath = ".\DomainReports"
    )
    
    # Ensure output directory exists
    $null = New-Item -ItemType Directory -Force -Path $OutputPath
    
    # Process input method
    if ($PSCmdlet.ParameterSetName -eq 'CSV') {
        if (-not (Test-Path $CsvPath)) {
            Write-Error "CSV file not found: $CsvPath"
            return
        }
        $DomainNames = Import-Csv $CsvPath | Select-Object -ExpandProperty DomainName
    }
    
    # Get auth headers
    $headers = Get-GoDaddyAuthHeader -ApiKey $ApiKey -ApiSecret $ApiSecret
    
    # Initialize results array using ArrayList for better performance
    $results = [System.Collections.ArrayList]::new()
    
    # Track requests per minute for rate limiting
    $requestCount = 0
    $requestStartTime = Get-Date
    
    foreach ($domain in $DomainNames) {
        # Check rate limit (60 requests per minute)
        if ($requestCount -ge 60) {
            $elapsedTime = (Get-Date) - $requestStartTime
            if ($elapsedTime.TotalSeconds -lt 60) {
                $sleepTime = 60 - $elapsedTime.TotalSeconds
                Write-Host "Rate limit reached. Waiting $($sleepTime.ToString('N0')) seconds..." -ForegroundColor Yellow
                Start-Sleep -Seconds $sleepTime
            }
            $requestCount = 0
            $requestStartTime = Get-Date
        }
        
        Write-Host "Checking domain: $domain" -ForegroundColor Yellow
        $result = Get-DomainAvailability -Domain $domain -Headers $headers -Environment $Environment
        $null = $results.Add($result)
        
        # Display progress
        $color = if ($result.Status -eq 'Success') { 'Green' } else { 'Red' }
        Write-Host "Domain $domain - Status: $($result.Status)" -ForegroundColor $color
        
        $requestCount++
    }
    
    # Generate reports
    Export-DomainReport -Results $results -OutputPath $OutputPath
    
    return $results
}

# # Example usage with test environment first:
# $params = @{
#     DomainNames = @(
#         "CloudCommand.com",
#         "CloudCommand.dev",
#         "CloudCommand.io"
#     )
#     ApiKey = "your_api_key_here"       # Replace with your actual API key
#     ApiSecret = "your_api_secret_here"  # Replace with your actual API secret
#     Environment = 'Test'                # Use 'Test' first, then 'Production'
#     OutputPath = "C:\DomainReports"
# }

# Test-BulkDomains @params








# Define TLD variations to check
$tlds = @('.com', '.dev', '.io', '.tech', '.blog', '.org')

# Define base names (removing spaces and special characters)
$baseNames = @(
    'CloudCommand',
    'PowershellNexus',
    'AzureArtisan',
    'IntuneInsights',
    'ScriptedSolutions',
    '365Elevated',
    'TheModernEngineer',
    'CloudCatalyst',
    'TechPathways',
    'ITEvolver',
    'CodeAndCloud',
    'ScriptsToSystems',
    'ScriptSavant',
    'ByteSizedTech',
    'TheAzureTrail',
    'CloudCrafted',
    'ShellShockIT',
    'MVPChronicles',
    'TheITMVP',
    'IntuneMVP'
)

# Create all domain combinations
$domains = foreach ($name in $baseNames) {
    foreach ($tld in $tlds) {
        $name + $tld
    }
}

# Parameters for domain checking
$params = @{
    DomainNames = $domains
    ApiKey = "3mM44WkB2Agf83_EnkggNdUnrStgfyQojMr7s"       # Replace with your actual API key
    ApiSecret = "MGLx3WXT2W1za19PsUgxm9"  # Replace with your actual API secret
    Environment = 'Test'                # Use 'Test' first, then 'Production'
    OutputPath = "C:\DomainReports"
}

# Preview domains to be checked
Write-Host "Domains to be checked:"
$domains | ForEach-Object { Write-Host $_ }

Write-Host "`nTotal domains to check: $($domains.Count)"

# Uncomment the following line to actually check the domains
Test-BulkDomains @params














# $params = @{
#     DomainNames = @(
#         "CloudCommand.com",
#         "CloudCommand.dev",
#         "CloudCommand.io"
#     )
#     ApiKey = "h1ySsB17Z9dE_Lanqzi6yXVy4gTjDKPxP29"
#     ApiSecret = "LGfX517nEnn8rkYUDH18De"
#     Environment = 'Production'
#     OutputPath = "C:\DomainReports"
# }

# Test-BulkDomains @params